'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mhidLRU = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _debugHelpers = require('../internal/debug-helpers.js');

var _jsonParse = require('../internal/jsonParse.js');

var _houndRequest = require('../../request/hound-request.js');

var _houndRequest2 = _interopRequireDefault(_houndRequest);

var _MHCache = require('../internal/MHCache.js');

var _MHCache2 = _interopRequireDefault(_MHCache);

var _MHMetadata = require('../meta/MHMetadata.js');

var _MHSocial = require('../social/MHSocial.js');

var _MHSocial2 = _interopRequireDefault(_MHSocial);

var _MHUserSocial = require('../social/MHUserSocial.js');

var _MHUserSocial2 = _interopRequireDefault(_MHUserSocial);

var _MHSocialMetrics = require('../social/MHSocialMetrics.js');

var _MHSocialMetrics2 = _interopRequireDefault(_MHSocialMetrics);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var childrenConstructors = {};
var __cachedRootResponses = {};

// Create Cache
var mhidLRU = exports.mhidLRU = new _MHCache2.default(3000);

if (typeof window !== 'undefined') {
  if (window.location.host === 'local.mediahound.com:2014') {
    window.mhidLRU = mhidLRU;
  }
}

// Symbols for Element hiding
var lastSocialRequestIdSym = Symbol('lastSocialRequestId'),
    socialSym = Symbol('social');

// TODO: editable primary and secondary image properties using Symbols

// Base MediaHound Object

var MHObject = function () {

  /** MHObject Constructor
   *  @constructor
   * MediaHound Object constructors take a single parameter {Object | JSON String}
   * If the argument is an object properties will be read and placed properly
   *  if a prop doesn't exist and is optional it will be replaced with a null value.
   * If the argument is a string it will be passed through JSON.parse and then the constructor will continue as normal.
   *
   *  @param args - { Object | JSON String }
   *
   *    Require Param Props
   *      mhid    - { MediaHound ID string }
   *
   *  Optional Param Props
   *      name            - { String }
   *      altId           - { String }
   *      primaryImage    - { MHImage }
   *      secondaryImage  - { MHImage }
   *      createdDate     - { Date }
   *
   */

  function MHObject(args) {
    _classCallCheck(this, MHObject);

    (0, _jsonParse.jsonCreateWithArgs)(args, this);

    this.cachedResponses = {};
  }

  _createClass(MHObject, [{
    key: 'isEqualToMHObject',


    /**
     * mhObj.isEqualToMHObject(otherObj)
     *
     * @param { <MHObject> }  - MediaHound Type to check against
     * @return { Boolean }    - True or False if mhids match
     *
     */
    value: function isEqualToMHObject(otherObj) {
      if (otherObj && otherObj.metadata.mhid) {
        return this.metadata.mhid === otherObj.metadata.mhid;
      }
      return false;
    }
    // TODO Add deep equality check?
    // might be useful for checking for changes in cache'd objects

    /**
     * mhObj.hasMhid(mhid)
     *
     * @param {string} mhid - a string mhid to check against this object
     * @returns {boolean}
     */

  }, {
    key: 'hasMhid',
    value: function hasMhid(mhid) {
      if (typeof mhid === 'string' || mhid instanceof String) {
        return this.metadata.mhid === mhid;
      }
      return false;
    }

    // TODO Could change as needed

  }, {
    key: 'toString',
    value: function toString() {
      return this.className + ' with mhid ' + this.metadata.mhid + ' and name ' + this.mhName;
    }
  }, {
    key: 'mergeWithData',
    value: function mergeWithData(args) {
      (0, _jsonParse.jsonMergeWithArgs)(args, this);
    }

    /**
     * MHObject.fetchByMhid(mhid)
     *
     * @param   { String        } mhid  - valid MediaHound ID
     * @param   { String        } view  - set to basic, basic_social, extended, extended_social, full, defaults to basic.
     * @param   { boolean=false } force - set to true to re-request for the given mhid
     * @return  { Promise       } - resloves to specific MHObject sub class
     *
     */

  }, {
    key: 'subendpoint',


    /**
     * mhObj.subendpoint(sub)
     *
     * @param   { String } - subendpoint to be added onto this.endpoint
     * @returns { String } - example with ('like'): 'graph/media/mhmov1000009260/like'
     *
     */
    value: function subendpoint(sub) {
      if (typeof sub !== 'string' && !(sub instanceof String)) {
        throw new TypeError('Sub not of type string or undefined in (MHObject).subendpoint.');
      }
      return this.endpoint + '/' + sub;
    }
  }, {
    key: 'fetchSocial',


    /**
     * mhObj.fetchSocial()
     * Calls server for new social stats
     * @param {boolean} force - Forces an http request if set to true
     * @return  { Promise }  - Resolves to Social stats as returned by the server
     *
     */
    value: function fetchSocial() {
      var _this = this;

      var force = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

      var path = this.subendpoint('social');

      if (!force && this.social instanceof _MHSocial2.default) {
        return Promise.resolve(this.social);
      }
      return (0, _houndRequest2.default)({
        method: 'GET',
        endpoint: path
      }).then(function (parsed) {
        return _this.social = new _MHSocial2.default(parsed);
      }.bind(this)).catch(function (err) {
        console.warn('fetchSocial:', err);
      });
    }

    /** TODO: Move to Objects that actually use it, i.e. not MHAction
     * mhObj.fetchFeed(view, page, size)
     *
     * @param { string=full   } view - the view param
     * @param { number=0      } page - the zero indexed page number to return
     * @param { number=12     } size  - the number of items to return per page
     * @param { Boolean=false } force
     *
     * @return { houndPagedRequest }  - MediaHound paged request object for this feed
     *
     */

  }, {
    key: 'fetchFeed',
    value: function fetchFeed() {
      var view = arguments.length <= 0 || arguments[0] === undefined ? 'full' : arguments[0];
      var size = arguments.length <= 1 || arguments[1] === undefined ? 12 : arguments[1];
      var force = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

      var path = this.subendpoint('feed');
      return this.fetchPagedEndpoint(path, view, size, force);
    }

    /* TODO: DocJS
    * mhMed.fetchImages()
    *
    * @param force { Boolean } - force refetch of content
    * @return { Promise } - resolves to
    *
    */

  }, {
    key: 'fetchImages',
    value: function fetchImages() {
      var view = arguments.length <= 0 || arguments[0] === undefined ? 'full' : arguments[0];
      var size = arguments.length <= 1 || arguments[1] === undefined ? 20 : arguments[1];
      var force = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

      var path = this.subendpoint('images');
      return this.fetchPagedEndpoint(path, view, size, force);
    }

    /*
     * mhContributor.fetchCollections(force)
     *
     * @return { Promise }  - resolves to server response of collections for this MediaHound object
     *
     */

  }, {
    key: 'fetchCollections',
    value: function fetchCollections() {
      var view = arguments.length <= 0 || arguments[0] === undefined ? 'full' : arguments[0];
      var size = arguments.length <= 1 || arguments[1] === undefined ? 12 : arguments[1];
      var force = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

      var path = this.subendpoint('collections');
      return this.fetchPagedEndpoint(path, view, size, force);
    }

    /* TODO: DocJS
    * mhMed.fetchBaseTraits()
    *
    * @param force { Boolean } - force refetch of content
    * @return { Promise } - resolves to
    *
    */

  }, {
    key: 'fetchBaseTraits',
    value: function fetchBaseTraits() {
      var view = arguments.length <= 0 || arguments[0] === undefined ? 'full' : arguments[0];
      var size = arguments.length <= 1 || arguments[1] === undefined ? 20 : arguments[1];
      var force = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

      var path = this.subendpoint('baseTraits');
      return this.fetchPagedEndpoint(path, view, size, force);
    }
  }, {
    key: 'fetchGraphGenres',
    value: function fetchGraphGenres() {
      var view = arguments.length <= 0 || arguments[0] === undefined ? 'full' : arguments[0];
      var size = arguments.length <= 1 || arguments[1] === undefined ? 20 : arguments[1];
      var force = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

      var path = this.subendpoint('graphGenres');
      return this.fetchPagedEndpoint(path, view, size, force);
    }

    /**
     *
     * mhObj.takeAction(action)
     *
     * @param   { string } action - The action to take, should be accessed from MHSocial.LIKE, MHSocial.FOLLOW, etc.
     *
     * @return  { Promise } - resolves to server response of action call
     *
     */

  }, {
    key: 'takeAction',
    value: function takeAction(action) {
      var _this2 = this;

      if (typeof action !== 'string' && !(action instanceof String)) {
        throw new TypeError('Action not of type String or undefined');
      }
      if (!_MHSocial2.default.SOCIAL_ACTIONS.some(function (a) {
        return action === a;
      })) {
        throw new TypeError('Action is not of an accepted type in mhObj.takeAction');
      }

      (0, _debugHelpers.log)('in takeAction, action: ' + action + ', obj: ' + this.toString());

      var path = this.subendpoint(action),
          requestId = Math.random(),
          original = this.social,
          self = this;

      // Expected outcome
      if (this.social instanceof _MHSocial2.default) {
        this.social = this.social.newWithAction(action);
      }

      // Save request id to check against later
      this[lastSocialRequestIdSym] = requestId;

      // Return promise to new Social as returned from the server
      return (0, _houndRequest2.default)({
        method: 'PUT',
        endpoint: path
      }).then(function (socialRes) {
        var newSocial = new _MHSocial2.default(socialRes.social);

        // only update if this is the last request returning
        if (_this2[lastSocialRequestIdSym] === requestId) {
          self.social = newSocial;
        }
        //log('in take action response, newSocial: ', newSocial);
        return newSocial;
      }).catch(function (err) {
        if (_this2[lastSocialRequestIdSym] === requestId) {
          self.social = original;
        }
        throw err;
      });
    }
  }, {
    key: 'responseCacheKeyForPath',
    value: function responseCacheKeyForPath(path, params) {
      return '__cached_' + path + '_' + JSON.stringify(params, function (k, v) {
        if (k === 'access_token') {
          return undefined;
        }
        return v;
      });;
    }
  }, {
    key: 'cachedResponseForPath',
    value: function cachedResponseForPath(path, params) {
      var cacheKey = this.responseCacheKeyForPath(path, params);
      return this.cachedResponses[cacheKey];
    }
  }, {
    key: 'setCachedResponse',
    value: function setCachedResponse(response, path, params) {
      var cacheKey = this.responseCacheKeyForPath(path, params);
      this.cachedResponses[cacheKey] = response;
    }
  }, {
    key: 'fetchBucketedEndpoint',
    value: function fetchBucketedEndpoint(path, filters, view, size) {
      var _this3 = this;

      var next = arguments.length <= 4 || arguments[4] === undefined ? null : arguments[4];
      var params = arguments.length <= 5 || arguments[5] === undefined ? {} : arguments[5];

      var promise;

      if (next) {
        promise = (0, _houndRequest2.default)({
          method: 'GET',
          url: next
        });
      } else {
        params.pageSize = size;
        params.view = view;
        if (filters) {
          params.filters = filters;
        }

        promise = (0, _houndRequest2.default)({
          method: 'GET',
          endpoint: path,
          params: params
        });
      }

      var finalPromise = promise.then(function (response) {
        var MHBucket = require('../container/MHBucket.js').default;
        var bucket = new MHBucket(response);

        bucket.fetchNextOperation = function (newNext) {
          return _this3.fetchBucketedEndpoint(path, filters, view, size, newNext);
        };

        return bucket;
      });

      return finalPromise;
    }
  }, {
    key: 'fetchPagedEndpoint',
    value: function fetchPagedEndpoint(path, view, size, force) {
      var _this4 = this;

      var next = arguments.length <= 4 || arguments[4] === undefined ? null : arguments[4];
      var params = arguments.length <= 5 || arguments[5] === undefined ? {} : arguments[5];

      params.pageSize = size;
      params.view = view;

      if (!force && !next) {
        var cached = this.cachedResponseForPath(path, params);
        if (cached) {
          return cached;
        }
      }

      var promise;

      if (next) {
        promise = (0, _houndRequest2.default)({
          method: 'GET',
          url: next
        });
      } else {
        promise = (0, _houndRequest2.default)({
          method: 'GET',
          endpoint: path,
          params: params
        });
      }

      var finalPromise = promise.then(function (response) {
        var MHPagedResponse = require('../container/MHPagedResponse.js').default;
        var pagedResponse = new MHPagedResponse(response);

        pagedResponse.fetchNextOperation = function (newNext) {
          return _this4.fetchPagedEndpoint(path, view, size, force, newNext);
        };

        return pagedResponse;
      });

      if (!next) {
        this.setCachedResponse(finalPromise, path, params);
      }

      return finalPromise;
    }
  }, {
    key: 'jsonProperties',
    get: function get() {
      return {
        metadata: _MHMetadata.MHMetadata,
        primaryImage: { mapper: MHObject.create },
        secondaryImage: { mapper: MHObject.create },
        social: _MHSocial2.default,
        userSocial: _MHUserSocial2.default,
        socialMetrics: _MHSocialMetrics2.default
      };
    }

    /** @property {MHSocial} social */

  }, {
    key: 'social',
    get: function get() {
      return this[socialSym] || null;
    },
    set: function set(newSocial) {
      if (newSocial instanceof _MHSocial2.default) {
        this[socialSym] = newSocial;
      }
      return this.social;
    }

    /**
     * MHObject.create(args)
     *
     * @param   { Object | JSON<String> | Array{Objects | JSON<Strings>} } - Array or, single Object or JSON of MediaHound Object definition(s).
     * @returns { <MHObject> } - Specific MediaHound Type. ex: MHMovie, MHAlbum, MHTrack, MHContributor, etc.
     *
     * returns null if can't find associated class
     */

  }, {
    key: 'type',
    get: function get() {
      return MHObject.isType(this);
    }

    /**
     * This uses the function.name feature which is shimmed if it doesn't exist during the child constructor registration process.
     * @property {string} className - the string class name for this object, ie: MHUser, MHMovie, MHPost, etc.
     */

  }, {
    key: 'className',
    get: function get() {
      return this.constructor.mhName;
    }
  }, {
    key: 'endpoint',


    /**
     * mhObj.endpoint
     *
     * @return { String } - ex: 'graph/media/mhmov1000009260'
     *
     */
    get: function get() {
      return this.constructor.rootEndpoint + '/' + this.metadata.mhid;
    }
  }], [{
    key: 'create',
    value: function create(args) {
      var saveToLRU = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

      if (args instanceof Array) {
        (0, _debugHelpers.log)('trying to create MHObject that is new: ' + args);
        //return args.map(MHObject.create); // <-- should probably be this once all MHObjs are done
        return args.map(function (value) {
          try {
            return MHObject.create(value);
          } catch (e) {
            (0, _debugHelpers.error)(e);
            return value;
          }
        });
      }
      try {

        if (args.mhid && args.metadata === undefined) {
          args.metadata = {
            'mhid': args.mhid,
            'altId': args.altId,
            'name': args.name
          };
        }

        //log(args.metadata.mhid)
        var mhid = args.metadata.mhid || args.mhid || undefined;
        var mhObj;
        //console.log('at start of creating... ',mhid,args);

        if (mhid !== 'undefined' && mhid !== null && args instanceof Object) {
          args.mhid = mhid;
          // check cache
          //log('in create function trying to parseArgs: \n\n' , args);

          var foundObject = mhidLRU.get(args.metadata.mhid);
          if (foundObject) {
            (0, _debugHelpers.log)('getting from cache in create: ' + args.metadata.mhid);
            foundObject.mergeWithData(args);
            return foundObject;
          }

          var prefix = MHObject.getPrefixFromMhid(mhid);
          (0, _debugHelpers.log)(prefix, new childrenConstructors[prefix](args));
          mhObj = new childrenConstructors[prefix](args);

          // if (prefix === 'mhimg') {
          //   // bypass cache
          // }
          // else {
          //   log('putting from create');
          //   mhidLRU.putMHObj(mhObj);
          // }
          //console.log('creating... ',prefix,': ', mhObj);
          if (saveToLRU) {
            mhidLRU.putMHObj(mhObj);
          }
          return mhObj;
        } else {
          mhObj = args;
          //log('creating without a prefix...', mhObj);
          return mhObj;
        }
      } catch (err) {
        //log(err);
        console.log(err);
        console.log(err.stack);
        if (err instanceof TypeError) {
          if (err.message === 'undefined is not a function') {
            (0, _debugHelpers.warn)('Unknown mhid prefix, see args object: ', args);
          }
          if (err.message === 'Args was object without mhid!') {
            //warn('Incomplete Object passed to create function: ', args);
          }
        }
        //error(err.stack); // turning off this error because it is really annoying!
        return null;
      }
      return null;
    }

    /***
     * Register Child Constructors
     *
     * MHObject.registerConstructor(mhClass)
     *
     * @param  { Function } mhClass - MediaHound Object constructor to be used within MHObject.create and other methods
     * @return { Boolean }                - Success(true) or Fail(false)
     *
     */

  }, {
    key: 'registerConstructor',
    value: function registerConstructor(mhClass, mhName) {
      // Add class name if function.name is not native
      // if (mhClass.name === undefined) {
      //   mhClass.name = mhClass.toString().match(/function (MH[A-Za-z]*)\(args\)/)[1];
      //   log('shimmed mhClass.name to: ' + mhClass.name);
      // }
      mhClass.mhName = mhName;
      //log('registering constructor: ' + mhClass.name);

      var prefix = mhClass.mhidPrefix;
      if (typeof prefix !== 'undefined' && prefix !== null && !(prefix in childrenConstructors)) {
        Object.defineProperty(childrenConstructors, prefix, {
          configurable: false,
          enumerable: true,
          writable: false,
          value: mhClass
        });
        return true;
      }
      return false;
    }

    /**
     * MHObject.prefixes
     *
     * @return { Array } - A list of MediaHound ID prefixes
     *
     * Note: This list contains only prefixes of types known to the MHObject.create method
     */
    // List of prefixes known to MHObject through registerConstructor

  }, {
    key: 'getPrefixFromMhid',


    /**
     * MHObject.getPrefixFromMhid(mhid)
     *
     * @param  { String } mhid - a valid MediaHound ID
     * @return { String } - a valid MediaHound ID prefix
     *
     */
    value: function getPrefixFromMhid(mhid) {
      for (var pfx in childrenConstructors) {
        if (childrenConstructors.hasOwnProperty(pfx) && new RegExp('^' + pfx).test(mhid)) {
          return pfx;
        }
      }
      return null;
    }

    /**
     * MHObject.getClassNameFromMhid(mhid)
     *
     * @param  { String } mhid - a valid MediaHound ID
     * @return { String } - the class name associated with the prefix
     *
     */

  }, {
    key: 'getClassNameFromMhid',
    value: function getClassNameFromMhid(mhid) {
      var pfx = MHObject.getPrefixFromMhid(mhid);
      if (childrenConstructors[pfx]) {
        return childrenConstructors[pfx].mhName;
      }
      return null;
    }

    /**
     * mhObj.mhidPrefix
     *
     * @return { String } - the MediaHound ID prefix associated with this MHObject.
     *
     * Note: Override at child level
     */

  }, {
    key: 'isMedia',


    // Type Checking
    // TODO: Update these checks for cross site scripting cases
    // case:
    //    instanceof only works if the object being checked was created
    //    in the same global scope as the constructor function it is being checked against
    value: function isMedia(toCheck) {
      return toCheck instanceof require('../media/MHMedia.js').default;
    }
  }, {
    key: 'isContributor',
    value: function isContributor(toCheck) {
      return toCheck instanceof require('../contributor/MHContributor.js').default;
    }
  }, {
    key: 'isAction',
    value: function isAction(toCheck) {
      return toCheck instanceof require('../action/MHAction.js').default;
    }
  }, {
    key: 'isUser',
    value: function isUser(toCheck) {
      return toCheck instanceof require('../user/MHUser.js').default;
    }
  }, {
    key: 'isCollection',
    value: function isCollection(toCheck) {
      return toCheck instanceof require('../collection/MHCollection.js').default;
    }
  }, {
    key: 'isImage',
    value: function isImage(toCheck) {
      return toCheck instanceof require('../image/MHImage.js').default;
    }
  }, {
    key: 'isTrait',
    value: function isTrait(toCheck) {
      return toCheck instanceof require('../trait/MHTrait.js').default;
    }
  }, {
    key: 'isSource',
    value: function isSource(toCheck) {
      return toCheck instanceof require('../source/MHSource.js').default;
    }
  }, {
    key: 'isType',
    value: function isType(obj) {
      var type = '';

      if (MHObject.isAction(obj)) {
        type = 'MHAction';
      } else if (MHObject.isMedia(obj)) {
        type = 'MHMedia';
      } else if (MHObject.isImage(obj)) {
        type = 'MHImage';
      } else if (MHObject.isCollection(obj)) {
        type = 'MHCollection';
      } else if (MHObject.isUser(obj)) {
        type = 'MHUser';
      } else if (MHObject.isContributor(obj)) {
        type = 'MHContributor';
      } else if (MHObject.isSource(obj)) {
        type = 'MHSource';
      } else if (MHObject.isTrait(obj)) {
        type = 'MHTrait';
      } else {
        type = null;
      }

      return type;
    }
  }, {
    key: 'enterWithMappedSourceIds',
    value: function enterWithMappedSourceIds(msis) {
      var endpoint = 'graph/enter/raw';
      var params = {
        ids: msis
      };

      return (0, _houndRequest2.default)({
        method: 'GET',
        endpoint: endpoint,
        params: params
      });
    }
  }, {
    key: 'fetchByMhid',
    value: function fetchByMhid(mhid) {
      var view = arguments.length <= 1 || arguments[1] === undefined ? 'full' : arguments[1];
      var force = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];


      if (typeof mhid !== 'string' && !(mhid instanceof String)) {
        throw TypeError('MHObject.fetchByMhid argument must be type string.');
      }

      if (view === null || view === undefined) {
        view = 'full';
      }

      (0, _debugHelpers.log)('in fetchByMhid, looking for: ', mhid, 'with view = ', view);

      // Check LRU for mhid
      if (!force) {
        var entryFromCache = mhidLRU.get(mhid);
        if (entryFromCache) {
          return Promise.resolve(entryFromCache);
        }
      }
      // Check LRU for altId
      if (!force) {
        var _entryFromCache = mhidLRU.getByAltId(mhid);
        if (_entryFromCache) {
          return Promise.resolve(_entryFromCache);
        }
      }

      var prefix = MHObject.getPrefixFromMhid(mhid),
          mhClass = childrenConstructors[prefix],
          newObj;

      if (prefix === null || typeof mhClass === 'undefined') {
        (0, _debugHelpers.warn)('Error in MHObject.fetchByMhid', mhid, prefix, mhClass);
        throw Error('Could not find correct class, unknown mhid: ' + mhid);
      }

      //console.log('fetching:', mhClass.rootEndpoint + '/' + mhid);

      return (0, _houndRequest2.default)({
        method: 'GET',
        endpoint: mhClass.rootEndpoint + '/' + mhid,
        params: {
          view: view
        }
      }).then(function (response) {
        newObj = MHObject.create(response);
        return newObj;
      });
    }

    /**
     * Children override
     *
     */

  }, {
    key: 'rootEndpointForMhid',


    /**
     * MHObject.rootEndpointForMhid(mhid)
     *
     * @param   { String } mhid - a valid MediaHound ID
     * @return  { String } - the endpoint for MediaHound Type of mhid
     *
     */
    value: function rootEndpointForMhid(mhid) {
      if (typeof mhid !== 'string' && !(mhid instanceof String)) {
        throw new TypeError('Mhid not of type string or undefined in rootEndpointForMhid');
      }

      var prefix = MHObject.getPrefixFromMhid(mhid),
          mhClass = childrenConstructors[prefix];

      if (prefix === null || typeof mhClass === 'undefined') {
        (0, _debugHelpers.warn)('Error in MHObject.rootEndpointForMhid', mhid, prefix, mhClass);
        throw new Error('Could not find correct class, unknown mhid: ' + mhid);
      }

      return mhClass.rootEndpoint;
    }
  }, {
    key: 'rootSubendpoint',
    value: function rootSubendpoint(sub) {
      if (typeof sub !== 'string' && !(sub instanceof String)) {
        throw new TypeError('Sub not of type string or undefined in (MHObject).rootSubendpoint.');
      }
      return this.rootEndpoint + '/' + sub;
    }
  }, {
    key: 'rootResponseCacheKeyForPath',
    value: function rootResponseCacheKeyForPath(path, params) {
      return '___root_cached_' + path + '_' + JSON.stringify(params, function (k, v) {
        if (k === 'access_token') {
          return undefined;
        }
        return v;
      });
    }
  }, {
    key: 'cachedRootResponseForPath',
    value: function cachedRootResponseForPath(path, params) {
      var cacheKey = this.rootResponseCacheKeyForPath(path, params);
      return __cachedRootResponses[cacheKey];
    }
  }, {
    key: 'setCachedRootResponse',
    value: function setCachedRootResponse(response, path, params) {
      var cacheKey = this.rootResponseCacheKeyForPath(path, params);
      __cachedRootResponses[cacheKey] = response;
    }
  }, {
    key: 'fetchRootBucketedEndpoint',
    value: function fetchRootBucketedEndpoint(path, view, size) {
      var _this5 = this;

      var next = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
      var params = arguments.length <= 4 || arguments[4] === undefined ? {} : arguments[4];

      var promise;

      if (next) {
        promise = (0, _houndRequest2.default)({
          method: 'GET',
          url: next
        });
      } else {
        params.pageSize = size;
        params.view = view;

        promise = (0, _houndRequest2.default)({
          method: 'GET',
          endpoint: path,
          params: params
        });
      }

      var finalPromise = promise.then(function (response) {
        var MHBucket = require('../container/MHBucket.js').default;
        var bucket = new MHBucket(response);

        bucket.fetchNextOperation = function (newNext) {
          return _this5.fetchRootBucketedEndpoint(path, view, size, newNext, params);
        };

        return bucket;
      });

      return finalPromise;
    }
  }, {
    key: 'fetchRootPagedEndpoint',
    value: function fetchRootPagedEndpoint(path, params, view, size, force) {
      var _this6 = this;

      var next = arguments.length <= 5 || arguments[5] === undefined ? null : arguments[5];

      params.view = view;
      params.pageSize = size;

      if (!force && !next) {
        var cached = this.cachedRootResponseForPath(path, params);
        if (cached) {
          return cached;
        }
      }

      var promise;
      if (next) {
        promise = (0, _houndRequest2.default)({
          method: 'GET',
          url: next
        });
      } else {
        promise = (0, _houndRequest2.default)({
          method: 'GET',
          endpoint: path,
          params: params
        });
      }

      var finalPromise = promise.then(function (response) {
        var MHPagedResponse = require('../container/MHPagedResponse.js').default;
        var pagedResponse = new MHPagedResponse(response);

        pagedResponse.fetchNextOperation = function (newNext) {
          return _this6.fetchRootPagedEndpoint(path, params, view, size, force, newNext);
        };

        return pagedResponse;
      });

      if (!next) {
        this.setCachedRootResponse(finalPromise, path, params);
      }

      return finalPromise;
    }
  }, {
    key: 'prefixes',
    get: function get() {
      return Object.keys(childrenConstructors);
    }
  }, {
    key: 'mhidPrefix',
    get: function get() {
      return null;
    }
  }, {
    key: 'rootEndpoint',
    get: function get() {
      return null;
    }
  }]);

  return MHObject;
}();

exports.default = MHObject;