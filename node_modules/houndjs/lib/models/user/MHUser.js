'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _debugHelpers = require('../internal/debug-helpers.js');

var _MHObject2 = require('../base/MHObject.js');

var _MHObject3 = _interopRequireDefault(_MHObject2);

var _MHRelationalPair = require('../container/MHRelationalPair.js');

var _MHRelationalPair2 = _interopRequireDefault(_MHRelationalPair);

var _MHMetadata = require('../meta/MHMetadata.js');

var _houndRequest = require('../../request/hound-request.js');

var _houndRequest2 = _interopRequireDefault(_houndRequest);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*global System, Blob, File */

//import { MHImage } from '../image/MHImage.js';

// MediaHound User Object

var MHUser = function (_MHObject) {
  _inherits(MHUser, _MHObject);

  function MHUser() {
    _classCallCheck(this, MHUser);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(MHUser).apply(this, arguments));
  }

  _createClass(MHUser, [{
    key: 'setPassword',


    /* TODO: change endpoint to CamelCase and to use mhid?
    * mhUser.setPassword()
    *
    * @return { Promise }
    *
    */
    value: function setPassword(password, newPassword) {

      if (!password || typeof password !== 'string' && !(password instanceof String)) {
        throw new TypeError('password must be type string in MHUser.newPassword');
      }
      if (!newPassword || typeof newPassword !== 'string' && !(newPassword instanceof String)) {
        throw new TypeError('newPassword must be type string in MHUser.newPassword');
      }
      var path = this.subendpoint('updatePassword');

      return (0, _houndRequest2.default)({
        method: 'POST',
        endpoint: path,
        withCredentials: true,
        data: {
          oldPassword: password,
          newPassword: newPassword
        }
      }).then(function (response) {
        return response;
      });
    }
    /* TODO: docJS
    *
    * mhUser.setProfileImage(image);
    *
    */

  }, {
    key: 'setProfileImage',
    value: function setProfileImage(image) {
      (0, _debugHelpers.log)('in setProfileImage with image: ', image);
      if (!image) {
        throw new TypeError('No Image passed to setProfileImage');
        //return Promise.resolve(null);
      }
      if (!(image instanceof Blob || image instanceof File)) {
        throw new TypeError('Image was not of type Blob or File.');
      }

      // If not current user throw error
      if (!this.isCurrentUser) {
        //throw new NoMHSessionError('No valid user session. Please log in to change profile picture');
        throw function () {
          var NoMHSessionError = function NoMHSessionError(message) {
            this.name = 'NoMHSessionError';
            this.message = message || '';
          };
          NoMHSessionError.prototype = Object.create(Error.prototype);
          NoMHSessionError.constructor = NoMHSessionError;
          return new NoMHSessionError('No valid user session. Please log in to change profile picture');
        }();
      }

      var path = this.subendpoint('uploadImage'),
          form = new FormData();

      form.append('data', image);

      (0, _debugHelpers.log)('path: ', path, 'image: ', image, 'form: ', form);

      // send form or file?
      return (0, _houndRequest2.default)({
        method: 'POST',
        endpoint: path,
        withCredentials: true,
        data: form
      }).then(function (primaryImage) {

        // var MHLoginSession = System.get('../../src/models/user/MHLoginSession.js').MHLoginSession;
        // //console.warn('circular dep: ', MHLoginSession);
        //var img = new MHImage(primaryImage);
        //MHLoginSession.updatedProfileImage(img);
        //return img;

        // TODO: wire back up the Event in MHLoginSession
        return primaryImage;
      });
    }

    /**
    * MHUser.fetchByUsername(username)
    *
    * @param { String } username - Username to fetch info for
    * @param { boolean} force - force fetch to server
    *
    * @return { Promise } - resolves to the MHUser object
    *
    */

  }, {
    key: 'fetchInterestFeed',


    /* TODO: add local cache
    * mhUsr.fetchInterestFeed(view, page, size)
    *
    * @param view { String } - the view type query parameter
    * @param page { Number } - the page number query parameter
    * @param size { Number } - the number of items per page
    *
    * @return { pagedRequest } - resolves to paged response from server, res.content contains array of data
    *
    */
    value: function fetchInterestFeed() {
      var view = arguments.length <= 0 || arguments[0] === undefined ? 'full' : arguments[0];
      var size = arguments.length <= 1 || arguments[1] === undefined ? 12 : arguments[1];
      var force = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

      var path = this.subendpoint('interestFeed');
      return this.fetchPagedEndpoint(path, view, size, force);
    }

    /* TODO: remove console.log debug stuffs
    * mhUsr.fetchOwnedCollections()
    *
    * @return { Promise }
    *
    */

  }, {
    key: 'fetchOwnedCollections',
    value: function fetchOwnedCollections() {
      var view = arguments.length <= 0 || arguments[0] === undefined ? 'full' : arguments[0];
      var size = arguments.length <= 1 || arguments[1] === undefined ? 12 : arguments[1];
      var force = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

      var path = this.subendpoint('ownedCollections');
      return this.fetchPagedEndpoint(path, view, size, force);
    }
  }, {
    key: 'fetchOwnedCollectionsByType',
    value: function fetchOwnedCollectionsByType(subType) {
      var view = arguments.length <= 1 || arguments[1] === undefined ? 'full' : arguments[1];
      var size = arguments.length <= 2 || arguments[2] === undefined ? 12 : arguments[2];
      var force = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

      var path = this.subendpoint('ownedCollections');
      return this.fetchPagedEndpoint(path, view, size, force, null, { subType: subType });
    }

    /**
    * mhObj.fetchSuggested(mhid,force)
    *
    * @param { string='full' } view - the view needed to depict each MHObject that is returned
    * @param { number=12     } size  - the number of items to return per page
    * @param { Boolean=false } force
    *
    * @return { houndPagedRequest }  - MediaHound paged request object for this feed
    *
    */

  }, {
    key: 'fetchSuggested',
    value: function fetchSuggested() {
      var view = arguments.length <= 0 || arguments[0] === undefined ? 'full' : arguments[0];
      var size = arguments.length <= 1 || arguments[1] === undefined ? 12 : arguments[1];
      var force = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

      var path = this.subendpoint('suggested');
      return this.fetchPagedEndpoint(path, view, size, force);
    }

    /**
    * mhUser.fetchFollowing()
    * @param force {boolean=false}
    * @returns {Promise}
    */

  }, {
    key: 'fetchFollowing',
    value: function fetchFollowing() {
      var view = arguments.length <= 0 || arguments[0] === undefined ? 'full' : arguments[0];
      var size = arguments.length <= 1 || arguments[1] === undefined ? 12 : arguments[1];
      var force = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

      var path = this.subendpoint('following');
      return this.fetchPagedEndpoint(path, view, size, force);
    }
  }, {
    key: 'fetchLiking',
    value: function fetchLiking() {
      var view = arguments.length <= 0 || arguments[0] === undefined ? 'full' : arguments[0];
      var size = arguments.length <= 1 || arguments[1] === undefined ? 12 : arguments[1];
      var force = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

      var path = this.subendpoint('liking');
      return this.fetchPagedEndpoint(path, view, size, force);
    }
  }, {
    key: 'fetchFollowers',
    value: function fetchFollowers() {
      var view = arguments.length <= 0 || arguments[0] === undefined ? 'full' : arguments[0];
      var size = arguments.length <= 1 || arguments[1] === undefined ? 12 : arguments[1];
      var force = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

      var path = this.subendpoint('followers');
      return this.fetchPagedEndpoint(path, view, size, force);
    }

    /*
    * mhUser.linkService()
    *
    * @return { Promise }
    *
    */

  }, {
    key: 'fetchServiceSettings',


    /*
    * mhUser.fetchServiceSettings()
    *
    * @return { Promise }
    *
    */
    value: function fetchServiceSettings(serv) {

      var service = serv || null;
      var path = this.subendpoint('settings');

      if (service === null) {
        console.warn('No service provided, aborting. First argument must include service name i.e. \'facebook\' or \'twitter\'.');
        return false;
      }

      return (0, _houndRequest2.default)({
        method: 'GET',
        endpoint: path + '/' + service,
        withCredentials: true,
        //data   : { 'successRedirectUrl' : 'http://www.mediahound.com',  'failureRedirectUrl' : 'http://www.mediahound.com'},
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json'
        }
      }).catch(function (response) {
        console.error(response);
      }).then(function (response) {
        if (response === undefined) {
          return 500;
        } else {
          return response;
        }
      });
    }

    /*
    * mhUser.fetchTwitterFollowers()
    *
    * @return { PagedRequest }
    *
    */

  }, {
    key: 'fetchTwitterFollowers',
    value: function fetchTwitterFollowers() {
      var view = arguments.length <= 0 || arguments[0] === undefined ? 'full' : arguments[0];
      var size = arguments.length <= 1 || arguments[1] === undefined ? 12 : arguments[1];
      var force = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

      var path = this.subendpoint('settings') + '/twitter/friends';
      return this.fetchPagedEndpoint(path, view, size, force);
    }

    /*
    * mhUser.fetchFacebookFriends()
    *
    * @return { PagedRequest }
    *
    */

  }, {
    key: 'fetchFacebookFriends',
    value: function fetchFacebookFriends() {
      var view = arguments.length <= 0 || arguments[0] === undefined ? 'full' : arguments[0];
      var size = arguments.length <= 1 || arguments[1] === undefined ? 12 : arguments[1];
      var force = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

      var path = this.subendpoint('settings') + '/facebook/friends';
      return this.fetchPagedEndpoint(path, view, size, force);
    }
  }, {
    key: 'jsonProperties',
    get: function get() {
      return _extends({}, _get(Object.getPrototypeOf(MHUser.prototype), 'jsonProperties', this), {
        metadata: _MHMetadata.MHUserMetadata
      });
    }
  }, {
    key: 'isCurrentUser',
    get: function get() {
      var currentUser = require('./MHLoginSession.js').default.currentUser;
      return this.isEqualToMHObject(currentUser);
    }

    /*
    * Register New User on MediaHound
    *  Required Params
    *    username          { String }
    *    password          { String }
    *    email             { String }
    *    firstName         { String }
    *    lastName          { String }
    * Returns Promise that resolves to a MHUser object.
    *
    */

  }], [{
    key: 'registerNewUser',
    value: function registerNewUser(username, password, email, firstName, lastName) {
      var options = arguments.length <= 5 || arguments[5] === undefined ? {} : arguments[5];

      var path = MHUser.rootEndpoint + '/new';
      var notString = function notString(obj) {
        return typeof obj !== 'string' && !(obj instanceof String);
      };

      // Check for required params
      if (notString(username)) {
        throw new TypeError('Username not of type string in MHUser.registerNewUser');
      }

      if (notString(password)) {
        throw new TypeError('Password not of type string in MHUser.registerNewUser');
      }

      if (notString(email)) {
        throw new TypeError('Email not of type string in MHUser.registerNewUser');
      }

      if (notString(firstName)) {
        throw new TypeError('First name not of type string in MHUser.registerNewUser');
      }

      if (notString(lastName)) {
        throw new TypeError('Last name not of type string in MHUser.registerNewUser');
      }

      var data = _extends({}, options, {
        username: username,
        password: password,
        email: email,
        firstName: firstName,
        lastName: lastName
      });

      return (0, _houndRequest2.default)({
        method: 'POST',
        endpoint: path,
        data: data
      });
    }

    /**
    * fetchSourceSettings(mhid)
    * @param mhid
    * Fetches the settings for the current logged in user.
    */

  }, {
    key: 'fetchSourceSettings',
    value: function fetchSourceSettings(mhid) {
      if (!mhid || typeof mhid !== 'string' && !(mhid instanceof String)) {
        throw new TypeError('mhid must be type string in MHUser.fetchSourceSettings');
      }
      var path = MHUser.rootEndpoint + '/' + mhid + '/settings/sources';

      return (0, _houndRequest2.default)({
        method: 'GET',
        endpoint: path
      }).then(function (response) {
        response = _MHRelationalPair2.default.createFromArray(response.content);
        console.log('valid settings response: ', response);
        return response;
      }).catch(function (error) {
        console.log('error in fetchSourceSettings: ', error.error.message);
        console.error(error.error.stack);
        return false;
      });
    }

    /**
    * updateSettings(mhid,updates)
    *
    * @param updates
    * updates must be passed into updateSettings as an object with three required params.
    * An example of updating the boolean value of onboarded.
    * {
    *   'operation':'replace',
    *   'property':'onboarded',
    *   'value':Boolean
    * }
    * operation refers to the actions 'replace', 'add', or 'remove'
    * property is the property you want to change, i.e. 'onboarded', 'access', or 'tooltips'
    * value is either a boolean or string based on context of the request
    *
    * Another exmaple for updating tooltips:
    * {
    *   'operation':'add',
    *   'property':'tooltips',
    *   'value':['webapptooltip1', 'webapptooltip2', 'webapptooltip3']
    * }
    * @returns {Promise}
    */

  }, {
    key: 'updateSettings',
    value: function updateSettings(mhid, updates) {
      if (updates === null || typeof updates === 'string' || Array.isArray(updates)) {
        throw new TypeError('Update data parameter must be of type object');
      }
      if (updates.operation === null || updates.property === null || updates.value === null) {
        throw new TypeError('Updates must include operation, property, and value as parameters.');
      }
      var path = MHUser.rootEndpoint + '/' + mhid + '/settings/internal/update';
      console.log(path, updates);
      return (0, _houndRequest2.default)({
        method: 'PUT',
        endpoint: path,
        withCredentials: true,
        data: updates
      }).catch(function (err) {
        console.log('error on profile update: ', err);
        throw err;
      });
    }

    /** TODO: refactor after new auth system
    *
    */

  }, {
    key: 'validateUsername',
    value: function validateUsername(username) {
      if (!username || typeof username !== 'string' && !(username instanceof String)) {
        throw new TypeError('Username must be type string in MHUser.validateUsername');
      }
      var path = MHUser.rootEndpoint + '/validate/username/' + encodeURIComponent(username);

      // returns 200 for acceptable user name
      // returns 406 for taken user name
      return (0, _houndRequest2.default)({
        method: 'GET',
        endpoint: path
      }).then(function (response) {
        return response;
      }).catch(function (error) {
        if (error.xhr.status === 406) {
          console.error('The username ' + username + ' is already taken.');
        } else {
          console.log('error in validate username: ', error.error.message);
          console.error(error.error.stack);
        }
        return false;
      });
    }

    /** TODO: refactor after new auth system
    *
    */

  }, {
    key: 'validateEmail',
    value: function validateEmail(email) {
      if (!email || typeof email !== 'string' && !(email instanceof String)) {
        throw new TypeError('Email must be type string in MHUser.validateEmail');
      }
      var path = MHUser.rootEndpoint + '/validate/email/' + encodeURIComponent(email);

      // returns 200 for acceptable user name
      // returns 406 for taken user name
      return (0, _houndRequest2.default)({
        method: 'GET',
        endpoint: path
      }).then(function (response) {
        //console.log('valid email response: ', response);
        return response;
      }).catch(function (error) {
        if (error.xhr.status === 406) {
          console.error('The email ' + email + ' is already registered.');
        } else {
          console.log('error in validate username: ', error.error.message);
          console.error(error.error.stack);
        }
        return false;
      });
    }
    /* TODO: change endpoint to CamelCase and to use mhid?
    * mhUser.forgotUsernameWithEmail()
    *
    * @return { Promise }
    *
    */

  }, {
    key: 'forgotUsernameWithEmail',
    value: function forgotUsernameWithEmail(email) {
      if (!email || typeof email !== 'string' && !(email instanceof String)) {
        throw new TypeError('Email must be type string in MHUser.forgotUsernameWithEmail');
      }
      var path = MHUser.rootEndpoint + '/forgotusername',
          data = {};

      data.email = email;

      // returns 200 for acceptable user name
      // returns 406 for taken user name
      return (0, _houndRequest2.default)({
        method: 'POST',
        endpoint: path,
        withCredentials: false,
        data: data
      }).then(function (response) {
        //  console.log('valid forgotUsernameWithEmail: ', response);
        return response;
      }).catch(function (error) {
        if (error.xhr.status === 400) {
          console.error('The email ' + email + ' is missing or an invalid argument.');
        } else if (error.xhr.status === 404) {
          console.error('The user with the email address ' + email + ' was not found.');
        } else {
          console.log('error in new forgotUsernameWithEmail: ', error.error.message);
          console.error(error.error.stack);
        }
        return false;
      });
    }
    /* TODO: change endpoint to CamelCase and to use mhid?
    * mhUser.forgotPasswordWithEmail()
    *
    * @return { Promise }
    *
    */

  }, {
    key: 'forgotPasswordWithEmail',
    value: function forgotPasswordWithEmail(email) {
      if (!email || typeof email !== 'string' && !(email instanceof String)) {
        throw new TypeError('Email must be type string in MHUser.forgotPasswordWithEmail');
      }
      var path = MHUser.rootEndpoint + '/forgotpassword',
          data = {};

      data.email = email;

      return (0, _houndRequest2.default)({
        method: 'POST',
        endpoint: path,
        withCredentials: false,
        data: data
      }).then(function (response) {
        console.log('valid forgotPasswordWithEmail: ', response);
        return response;
      }).catch(function (error) {
        if (error.xhr.status === 400) {
          console.error('The email ' + email + ' is missing or an invalid argument.');
        } else if (error.xhr.status === 404) {
          console.error('The user with the email address ' + email + ' was not found.');
        } else {
          console.log('error in new forgotPasswordWithEmail: ', error.error.message);
          console.error(error.error.stack);
        }
        return false;
      });
    }
    /* TODO: change endpoint to CamelCase and to use mhid?
    * mhUser.forgotPasswordWithEmail()
    *
    * @return { Promise }
    *
    */

  }, {
    key: 'forgotPasswordWithUsername',
    value: function forgotPasswordWithUsername(username) {
      if (!username || typeof username !== 'string' && !(username instanceof String)) {
        throw new TypeError('username must be type string in MHUser.forgotPasswordWithUsername');
      }
      var path = MHUser.rootEndpoint + '/forgotpassword',
          data = {};

      data.username = username;

      return (0, _houndRequest2.default)({
        method: 'POST',
        endpoint: path,
        withCredentials: false,
        data: data
      }).then(function (response) {
        console.log('valid forgotPasswordWithUsername: ', response);
        return response;
      }).catch(function (error) {
        if (error.xhr.status === 400) {
          console.error('The username ' + username + ' is missing or an invalid argument.');
        } else if (error.xhr.status === 404) {
          console.error('The user ' + username + ' was not found.');
        } else {
          console.log('error in forgotPasswordWithUsername: ', error.error.message);
          console.error(error.error.stack);
        }
        return false;
      });
    }
    /* TODO: change endpoint to CamelCase and to use mhid?
    * mhUser.newPassword()
    *
    * @return { Promise }
    *
    */

  }, {
    key: 'newPassword',
    value: function newPassword(password, ticket) {

      if (!password || typeof password !== 'string' && !(password instanceof String)) {
        throw new TypeError('password must be type string in MHUser.newPassword');
      }
      if (!ticket || typeof ticket !== 'string' && !(ticket instanceof String)) {
        throw new TypeError('ticket must be type string in MHUser.newPassword');
      }
      var path = MHUser.rootEndpoint + '/forgotpassword/finish',
          data = {};

      data.newPassword = password;
      data.ticket = ticket;

      return (0, _houndRequest2.default)({
        method: 'POST',
        endpoint: path,
        withCredentials: false,
        data: data
      }).then(function (response) {
        console.log('valid newPassword: ', response);
        return response;
      }).catch(function (error) {
        if (error.xhr.status === 400) {
          console.error('The password ' + password + ' is an invalid password.');
        } else if (error.xhr.status === 404) {
          console.error('The ticket ' + ticket + ' was not found.');
        } else {
          console.log('error in newPassword: ', error.error.message);
          console.error(error.error.stack);
        }
        return false;
      });
    }
  }, {
    key: 'fetchByUsername',
    value: function fetchByUsername(username) {
      var view = arguments.length <= 1 || arguments[1] === undefined ? 'full' : arguments[1];
      var force = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

      if (!username || typeof username !== 'string' && !(username instanceof String)) {
        throw new TypeError('Username not of type String in fetchByUsername');
      }
      if (_MHObject3.default.getPrefixFromMhid(username) != null) {
        throw new TypeError('Passed mhid to fetchByUsername, please use MHObject.fetchByMhid for this request.');
      }
      if (view === null || view === undefined) {
        view = 'full';
      }

      (0, _debugHelpers.log)('in fetchByUsername, looking for: ' + username);

      // Check LRU for altId === username
      if (!force) {
        var entryFromCache = _MHObject2.mhidLRU.getByAltId(username);
        if (entryFromCache) {
          return Promise.resolve(entryFromCache);
        }
      }

      var path = MHUser.rootEndpoint + '/lookup/' + username,
          newObj;

      return (0, _houndRequest2.default)({
        method: 'GET',
        endpoint: path,
        withCredentials: true,
        params: {
          view: view
        }
      }).then(function (response) {
        newObj = _MHObject3.default.create(response);
        _MHObject2.mhidLRU.putMHObj(newObj);
        return newObj;
      });
    }

    /* TODO: Refactor to api 1.0 specs
    * MHUser.fetchFeaturedUsers()
    *
    * @return { Promise } - resloves to an array of featured users of type MHUser
    *
    */

  }, {
    key: 'fetchFeaturedUsers',
    value: function fetchFeaturedUsers() {
      var path = this.rootSubendpoint('featured');
      return (0, _houndRequest2.default)({
        method: 'GET',
        endpoint: path
      }).then(function (response) {
        return Promise.all(_MHObject3.default.fetchByMhids(response));
      });
    }
  }, {
    key: 'linkService',
    value: function linkService(serv, succ, fail) {

      var service = serv || null;
      var success = succ || 'https://www.mediahound.com/';
      var failure = fail || 'https://www.mediahound.com/';

      if (service === null) {
        console.warn('No service provided, aborting. First argument must include service name i.e. \'facebook\' or \'twitter\'.');
        return false;
      }

      return (0, _houndRequest2.default)({
        method: 'GET',
        endpoint: MHUser.rootEndpoint + '/account/' + service + '/link?successRedirectUrl=' + success + '&failureRedirectUrl=' + failure,
        withCredentials: true,
        //data   : { 'successRedirectUrl' : 'http://www.mediahound.com',  'failureRedirectUrl' : 'http://www.mediahound.com'},
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json'
        }
      }).then(function (response) {
        console.log(response);
        return response;
      });
    }
    /*
    * mhUser.unlinkService()
    *
    * @return { Promise }
    *
    */

  }, {
    key: 'unlinkService',
    value: function unlinkService(serv) {
      var service = serv || null;

      if (service === null) {
        console.warn('No service provided, aborting. First argument must include service name i.e. \'facebook\' or \'twitter\'.');
        return false;
      }

      return (0, _houndRequest2.default)({
        method: 'GET',
        endpoint: MHUser.rootEndpoint + '/account/' + service + '/unlink',
        withCredentials: true,
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json'
        }
      }).then(function (response) {
        console.log(response);
        return response;
      });
    }
  }, {
    key: 'mhidPrefix',
    get: function get() {
      return 'mhusr';
    }
  }, {
    key: 'rootEndpoint',
    get: function get() {
      return 'graph/user';
    }
  }]);

  return MHUser;
}(_MHObject3.default);

exports.default = MHUser;


_MHObject3.default.registerConstructor(MHUser, 'MHUser');